# Blazing Darkness - Технічна документація

## Огляд
Blazing Darkness — це текстова рольова гра (RPG), реалізована на C++. У грі є головний герой, який може досліджувати різні локації, брати участь у боях із ворогами, збирати предмети та підвищувати рівень.

## Основна архітектура

### Головні компоненти

1. **Game (Гра)**
   - Центральний контролер гри
   - Керує станом гри та головним ігровим циклом
   - Обробляє введення користувача та перебіг гри
   - Координує роботу між різними системами гри

2. **World (Світ)**
   - Керує локаціями гри та навігацією
   - Реалізує карту світу на основі вузлів
   - Обробляє переходи між локаціями та дослідження

3. **Entities (Сутності)**
   - Базова система персонажів із атрибутами (здоров’я, атака, захист)
   - Головний герой із досвідом і рівнем
   - Система ворогів із різними типами та поведінкою

4. **Items (Предмети)**
   - Базова система предметів із властивостями та ефектами
   - Витратні предмети (наприклад, зілля здоров’я)
   - Керування інвентарем

## Документація компонентів

### Клас Game
- **Обов’язки**:
  - Ініціалізація та завершення гри
  - Керування головним циклом гри
  - Обробка введення користувача
  - Керування станом гри
  - Організація системи бою

- **Ключові методи**:
  - `run()`: Головний ігровий цикл
  - `handleCombat()`: Керує бойовими зіткненнями
  - `showInventory()`: Показує інвентар гравця
  - `showHelp()`: Виводить доступні команди

### Система світу

#### WorldMap
- Керує ігровим світом як графом з’єднаних локацій
- Обробляє переміщення гравця між локаціями
- Відстежує поточне положення гравця

#### LocationNode
- Представляє окрему локацію у світі гри
- Містить:
  - Назву та опис
  - Зв’язані локації (ліворуч/праворуч)
  - Присутніх ворогів
  - Предмети, доступні для збору

### Система сутностей

#### Character (Базовий клас)
- Основні атрибути:
  - Здоров’я / Максимальне здоров’я
  - Сила атаки
  - Захист
  - Рівень
- Загальні функції:
  - Дії в бою
  - Обчислення шкоди
  - Ефекти станів

#### Player (Гравець)
- Розширює Character, додаючи:
  - Очки досвіду
  - Прогресію рівнів
  - Керування інвентарем
  - Спеціальні здібності

#### Enemy (Ворог)
- Розширює Character, додаючи:
  - Нагороду досвіду за перемогу
  - Штучний інтелект (AI)
  - Таблиці здобичі (loot tables)

### Система предметів

#### Item (Базовий клас)
- Властивості:
  - Назва
  - Опис
  - Цінність
  - Повідомлення про використання
- Віртуальні методи:
  - `use(Character&)`: Застосовує ефект предмета
  - `getType()`: Повертає тип предмета

#### HealthPotion
- Відновлює здоров’я при використанні
- Налаштовувана кількість відновлення
- Одноразовий предмет

## Ігрова механіка

### Система бою
- Покроковий бій
- Формула шкоди: `damage = attacker's attack - (defender's defense / 2)`
- Отримання досвіду після перемоги над ворогом
- Підвищення рівня з покращенням характеристик

### Дослідження
- Переміщення між з’єднаними локаціями
- Відкриття предметів і ворогів
- Події та зустрічі, залежно від локації

### Керування інвентарем
- Збір і використання предметів
- Обмежена місткість інвентаря
- Складання предметів одного типу

## Технічні деталі реалізації

### Керування пам’яттю
- Розумні вказівники (`std::shared_ptr`, `std::unique_ptr`) для автоматичного керування пам’яттю
- Дотримання принципів RAII у всьому коді

### Шаблони проєктування
- Singleton для класів Game і Logger
- Factory для створення предметів
- Observer для ігрових подій

### Залежності
- Стандарт C++17 або новіший
- Без зовнішніх бібліотек (тільки стандартна бібліотека)

## Потік даних
1. Гравець вводить команду
2. Гра обробляє введення та оновлює стан
3. Світ оновлюється відповідно до дій гравця
4. Вирішуються взаємодії сутностей
5. Гра виводить новий стан у консоль

## Обробка помилок
- Перевірка введення користувача
- Перевірка завантаження ресурсів
- Коректне опрацювання крайових випадків
- Логування важливих подій гри

## Оптимізація продуктивності
- Ефективні структури даних для стану гри
- Мінімальні виділення пам’яті під час гри
- Оптимізоване виведення для текстового інтерфейсу

## Можливості розширення
1. Додавання нових типів предметів
2. Реалізація нових поведінок ворогів
3. Розширення карти світу
4. Додавання нових механік (наприклад, квести, крафт)

## Відомі обмеження
- Однопоточна реалізація
- Проста поведінка AI
- Обмежена збережуваність світу
